# App2AppProvider Technical Design (COM RPC)

Status: Active
Audience: AppGateway and Provider implementers using WPEFramework COM
Transport: COM RPC (WPEFramework COM), no JSON-RPC or WebSocket usage

This document describes the App2AppProvider architecture using COM RPC for:
- AppGateway -> App2AppProvider (capability invocation, registration management)
- App2AppProvider -> AppGateway (responses/errors delivery)

All inter-component calls are strongly-typed COM method calls. Payloads are opaque and may be carried as byte buffers or UTF-8 strings; encoding is an implementation detail of the endpoints (e.g., JSON, CBOR, Protobuf), not a transport concern.

Important type note: connectionId is a numeric identifier (uint32_t) throughout the system (not a string or GUID).

## Goals

- Strongly-typed transport with COM RPC across process boundaries.
- Clear capability registration/lookup and correlation-based routing.
- Reliable asynchronous response/error delivery from providers to the original consumer via AppGateway.
- Clean separation of concerns: registry, correlation store, gateway responder.

## Components

- AppGateway
  - Accepts consumer requests using system-specific means.
  - Calls the App2AppProvider COM interface to invoke capabilities on behalf of the consumer.
  - Exposes a COM sink interface for receiving final results or errors for delivery back to the consumer.

- App2AppProvider
  - Maintains a capability -> provider registry.
  - Creates and tracks correlation IDs linking a provider call to a consumer context.
  - Calls into the provider COM interface to dispatch requests.
  - Calls back into AppGateway COM sink with final result/error.

- Provider App (implements a capability)
  - Registers/unregisters a capability with App2AppProvider, providing a COM callback interface to receive requests.
  - Receives capability invocations via COM.
  - Emits success or error via a COM response sink provided per invocation.

## Interfaces

The following interfaces are defined as C++ COM (pure-virtual) contracts in the `WPEFramework::Exchange` namespace. Methods return `uint32_t` using WPEFramework `Core::ERROR_*` codes. Out parameters are explicitly annotated.

Note: These are conceptual definitions. Exact signatures/namespaces can be aligned with your project’s interface header conventions.
Type update: `connectionId` is a numeric identifier of type `uint32_t` in all structures, signatures, and flows.

```cpp
namespace WPEFramework {
namespace Exchange {

// Request-scoped identity allowing the gateway to route the reply.
struct RequestContext {
    uint32_t         requestId;     // Incoming request ID from the consumer
    uint32_t         connectionId;  // Numeric connection identifier (uint32_t, e.g., COM ChannelId)
    string           appId;         // Authenticated app identity
};

// Optional opaque payload container carried across COM.
// Choose one of these two approaches (project-wide choice):
// 1) UTF-8 string payload
// 2) Byte buffer via IBuffer
struct InvocationPayload {
    string           utf8;          // If using string payloads
    // Alternatively, Core::ProxyType<Core::IBuffer> buffer; // If using binary payloads
};

// Invocation parameters App2AppProvider passes to providers.
struct InvocationRequest {
    string           correlationId; // Generated by App2AppProvider
    string           capability;    // Capability being invoked
    RequestContext   context;       // Consumer routing context (echoed back as-is)
    InvocationPayload payload;      // Opaque payload
};

// Result or error contracts a provider emits back.
struct ProviderError {
    int32_t          code;
    string           message;
};

// COM sink the provider uses to deliver a response for a specific invocation.
struct IAppProviderResponse : virtual public Core::IUnknown {
    enum { ID = 0x00000ABC /* Example GUID placeholder */ };

    virtual /* Core::ERROR_* */ uint32_t Success(const string& correlationId,
                                                 const string& capability,
                                                 const InvocationPayload& result) = 0;

    virtual /* Core::ERROR_* */ uint32_t Error(const string& correlationId,
                                               const string& capability,
                                               const ProviderError& error) = 0;
};

// COM interface a provider implements to receive requests.
struct IAppProvider : virtual public Core::IUnknown {
    enum { ID = 0x00000ABD /* Example GUID placeholder */ };

    // App2AppProvider calls this for each consumer invocation.
    // The response must be returned asynchronously via the provided 'sink'.
    virtual /* Core::ERROR_* */ uint32_t OnRequest(const InvocationRequest& request,
                                                   IAppProviderResponse* sink) = 0;
};

// COM interface the AppGateway exposes to receive replies.
struct IAppGatewayResponses : virtual public Core::IUnknown {
    enum { ID = 0x00000ABE /* Example GUID placeholder */ };

    // Exactly one of 'result' or 'error' must be populated by the caller.
    virtual /* Core::ERROR_* */ uint32_t Respond(const RequestContext& context,
                                                 const InvocationPayload* result,  // nullable
                                                 const ProviderError* error) = 0;  // nullable
};

// Main App2AppProvider COM interface.
struct IApp2AppProvider : virtual public Core::IUnknown {
    enum { ID = 0x00000ABF /* Example GUID placeholder */ };

    // AppGateway sets a response sink to be used for delivering final results/errors.
    virtual void SetGatewaySink(IAppGatewayResponses* sink) = 0;

    // Providers register/unregister capabilities.
    virtual /* Core::ERROR_* */ uint32_t Register(const string& capability,
                                                  IAppProvider* provider,
                                                  const RequestContext& context,
                                                  bool& registered /* out */) = 0;

    virtual /* Core::ERROR_* */ uint32_t Unregister(const string& capability,
                                                    IAppProvider* provider,
                                                    const RequestContext& context,
                                                    bool& registered /* out */) = 0;

    // AppGateway invokes a capability on behalf of a consumer.
    virtual /* Core::ERROR_* */ uint32_t Invoke(const RequestContext& context,
                                                const string& capability,
                                                const InvocationPayload& payload,
                                                string& correlationId /* out */) = 0;

    // Informational: clean up state on connection teardown.
    virtual void OnConnectionClosed(uint32_t connectionId) = 0;
};

} // namespace Exchange
} // namespace WPEFramework
```

### Error codes

- All synchronous returns use `Core::ERROR_*` codes:
  - `Core::ERROR_NONE` on success.
  - `Core::ERROR_BAD_REQUEST` for invalid parameters/shapes.
  - `Core::ERROR_UNKNOWN_KEY` (or similar) when an unknown correlation ID is referenced.
  - `Core::ERROR_UNAVAILABLE` when no provider is registered for a capability.
  - `Core::ERROR_GENERAL` (or a more specific code) for dispatch/transport errors.

Exact values depend on the WPEFramework version; align with your project’s shared error headers.

## Data Flow

### 1) Provider registration

1. Provider obtains a reference to `Exchange::IApp2AppProvider`.
2. Provider calls:
   - `IApp2AppProvider::Register(capability, this /* IAppProvider* */, context, registered[out])`
3. App2AppProvider stores:
   - capability → ProviderEntry { provider(IAppProvider*), appId, connectionId (uint32_t), registeredAt }
4. Return `Core::ERROR_NONE` with `registered = true` if successful.

Unregistration mirrors the above using `Unregister`.

### 2) AppGateway sets the response sink

1. AppGateway creates/obtains an implementation of `IAppGatewayResponses`.
2. AppGateway calls `IApp2AppProvider::SetGatewaySink(gatewaySink)`.
3. App2AppProvider retains a reference to `gatewaySink` for delivering responses/errors.

### 3) Consumer invocation (AppGateway → App2AppProvider)

1. AppGateway receives a consumer request, builds `RequestContext` and `InvocationPayload`.
2. AppGateway calls:
   - `IApp2AppProvider::Invoke(context, capability, payload, correlationId[out])`
3. App2AppProvider:
   - Validates params.
   - Looks up provider by `capability`.
   - Creates `correlationId` and stores a `ConsumerContext` derived from `RequestContext`.
   - Builds `InvocationRequest{ correlationId, capability, context, payload }`.
   - Calls provider: `IAppProvider::OnRequest(request, providerSink)` where `providerSink` is an ephemeral `IAppProviderResponse` implementation bound to the correlation.

4. Synchronous return:
   - On success: `Core::ERROR_NONE` and `correlationId` populated.
   - On provider missing: `Core::ERROR_UNAVAILABLE`.
   - On validation/dispatch failure: appropriate `Core::ERROR_*`.

### 4) Provider emits a result or error (Provider → App2AppProvider)

- When ready, the provider responds via the `providerSink` it received in `OnRequest`:
  - Success: `IAppProviderResponse::Success(correlationId, capability, resultPayload)`
  - Error: `IAppProviderResponse::Error(correlationId, capability, {code, message})`

App2AppProvider:
- Validates `correlationId`, retrieves and erases the stored `ConsumerContext`.
- Forwards the outcome to AppGateway using COM.

### 5) App2AppProvider delivers to AppGateway (App2AppProvider → AppGateway)

App2AppProvider calls:
- `IAppGatewayResponses::Respond(consumerContext, &resultPayload, nullptr)` on success
- `IAppGatewayResponses::Respond(consumerContext, nullptr, &error)` on error

AppGateway uses the `RequestContext` to route the reply back to the original consumer.

### 6) Connection teardown

When a connection closes (provider or consumer):
- The hosting platform calls `IApp2AppProvider::OnConnectionClosed(uint32_t connectionId)`.
- App2AppProvider:
  - Removes any provider registrations bound to the connection.
  - Deletes any outstanding correlations for that connection to prevent leaks.

## Architectural Notes

- No JSON-RPC or WebSocket: All interactions use COM RPC with strongly-typed interfaces.
- Payload neutrality: Payloads are opaque to the transport. Teams are free to encode structured data (e.g., JSON, CBOR) inside the chosen payload representation (string or buffer).
- Asynchronous responses: Achieved via a per-invocation COM sink `IAppProviderResponse` and a gateway-wide COM sink `IAppGatewayResponses`.
- Correlation store: Maintained inside App2AppProvider to map `correlationId` → `ConsumerContext`. Entries are one-shot and removed upon completion.
- Registry: `capability` → `IAppProvider*`. Per-connection tracking allows bulk cleanup on teardown.
- Threading/reentrancy: Implementations must follow WPEFramework COM threading guarantees. Avoid reentrant calls that might deadlock; dispatch provider calls on appropriate executors if necessary.
- Lifetime management: All COM references follow `AddRef`/`Release`. Ensure sinks and providers remain valid for the duration they are referenced. App2AppProvider must release response sinks after completion.

## Proxy/Stub Generation and Linking

- Define the interface headers under `WPEFramework::Exchange`.
- Use the provided Proxy/Stub generator tooling (WPEFramework `ProxyStubGenerator`) to generate marshalling code.
- Link against:
  - `libWPEFrameworkCOM.so`
  - `libWPEFrameworkProxyStubs.so`
  - `libWPEFrameworkMarshalling.so`
  - Project-specific generated proxy/stub objects
- Ensure the COM IDs (`enum { ID = ... }`) are unique and stable. Use your project’s GUID allocation process.

## Interface Summary

- IApp2AppProvider
  - SetGatewaySink(IAppGatewayResponses* sink)
  - Register(capability, IAppProvider* provider, RequestContext ctx, bool& registered)
  - Unregister(capability, IAppProvider* provider, RequestContext ctx, bool& registered)
  - Invoke(RequestContext ctx, capability, InvocationPayload payload, string& correlationId)
  - OnConnectionClosed(uint32_t connectionId)

- IAppProvider
  - OnRequest(InvocationRequest request, IAppProviderResponse* sink)

- IAppProviderResponse
  - Success(correlationId, capability, resultPayload)
  - Error(correlationId, capability, error)

- IAppGatewayResponses
  - Respond(RequestContext ctx, resultPayload?, error?)

## Differences from Prior JSON-centric approach

- Transport: COM RPC instead of JSON-RPC/WS.
- Typing: Strongly-typed interfaces rather than method strings and JSON envelopes.
- Callbacks: COM sinks (`IAppProviderResponse`, `IAppGatewayResponses`) replace JSON-RPC methods for returning responses/errors.
- Error handling: `Core::ERROR_*` codes for synchronous calls; typed `ProviderError` for async errors.

## Security Considerations

- `RequestContext.appId` and `RequestContext.connectionId (uint32_t)` must originate from authenticated/authorized sources.
- Capability names should be validated against policy to ensure only authorized apps can register/handle them.
- Avoid leaking `correlationId` outside intended boundaries. Treat it as a transient identifier.
- Validate payload sizes and enforce limits to prevent resource exhaustion.

## Implementation Hints

- Correlation IDs: Use cryptographically strong or sufficiently unique identifiers for large-scale systems.
- Timeouts: Optionally implement timeouts for outstanding correlations, emitting an error via AppGateway sink if providers take too long.
- Logging: Redact sensitive fields; focus on capability names, correlation IDs, and error codes/messages.
- Testing: Stub `IAppProvider` and `IAppGatewayResponses` to verify registry, correlation, and dispatch flows without external dependencies.
